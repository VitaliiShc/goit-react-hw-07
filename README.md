Книга контактів

- Створіть репозиторій з назвою goit-react-hw-07
- При здачі домашньої роботи надайте два посилання: одне на вихідні файли та інше на робочу сторінку завдання на Vercel.
- Проект повинен бути створений за допомогою Vite.
- Під час запуску коду завдання в консолі не повинно бути помилок або попереджень.
- Для кожного компонента у папці src/components є окрема папка, яка містить JSX файл самого React компонента та файл його стилів. Назва папки, файла компонента (з розширенням .jsx) та файла стилів (перед .module.css) однакова і відповідає назвам, вказаним у завданнях (якщо вони були).
- Для експорту компонентів використовується експорт за замовчуванням (export default).
- JS-код має бути чистим і зрозумілим, використовуйте Prettier.
- Використана бібліотека Redux Toolkit
- Стилізація повинна бути виконана за допомогою CSS-модулів.

Виконай рефакторинг коду застосунку «Книга контактів» із домашнього завдання попереднього модуля.

- Видали код, що відповідає за зберігання та читання контактів з локального сховища, тобто код пов’язаний з Redux Persist.
- Додай взаємодію з бекендом для зберігання контактів.

Бекенд
Створи свій персональний бекенд для розробки за допомогою UI-сервісу mockapi.io. Зареєструйся використовуючи свій обліковий запис GitHub та обери безкоштовний план.

Форма стану
Додай у стан Redux обробку індикатора завантаження та помилки HTTP-запитів. Для цього зміни форму стану слайсу контактів, додавши властивості loading та error.
{
  contacts: {
    items: [],
    loading: false,
    error: null
  },
  filters: {
name: ""
}
}

Операції
В папці redux створи файл contactsOps.js для зберігання асинхронних генераторів екшенів.

- Використовуй функцію createAsyncThunk для оголошення операцій.
- Для виконання HTTP-запитів використай бібліотеку axios.

Оголоси наступні операції:

- fetchContacts - одержання масиву контактів (метод GET) запитом. Базовий тип екшену це рядок "contacts/fetchAll".
- addContact - додавання нового контакту (метод POST). Базовий тип екшену це рядок "contacts/addContact".
- deleteContact - видалення контакту по ID (метод DELETE). Базовий тип екшену це рядок "contacts/deleteContact".

Для коректного опрацювання помилки HTTP-запиту в середині операцій, використай конструкцію try...catch, та у блоці catch поверни результат виклику методу thunkAPI.rejectWithValue.

Обробку усіх трьох екшенів (fulfilled, rejected, pending) та зміну даних у стані Redux зроби у властивості extraReducers слайсу контактів, а от властивість reducers з нього — прибери.

Мемоізація селекторів

Після додавання властивостей loading та error у слайс контактів, виникне проблема оптимізаціі фільтрування контактів, так як вираз фільтрування буде виконуватись не тільки при зміні контактів або фільтру, а також при зміні loading та error.

Для вирішення цієї задачі:

- У файлі слайсу контактів contactsSlice.js створи та експортуй мемоізований селектор selectFilteredContacts за допомогою функції createSelector.
- Селектор повинен залежати від поточних масиву контактів і значення фільтра, та повертати відфільтрований масив контактів.
- Селектор selectFilteredContacts імпортується у компонент списка контактів ContactList.jsx та використовується у useSelector.

Колекція контактів

Оскільки твоя колекція контактів тепер зберігається на бекенді, то:

- При завантаженні додатка запит на бекенд для отримання масиву контактів зроби саме в компоненті Арр.
- При створенні нового контакту додавати йому унікальний ідентифікатор більше не потрібно, це буде робити сам бекенд і повертати у відповідь об’єкт нового контакту.

Результати

Завдання вирішено правильно (компонент Store file)
Правильне використання configureStore для створення сховища Redux.
Правильно структуровано головний reducer, об'єднуючи різні reducer-и окремих функцій.

Завдання вирішено правильно (компонент Filters slice file)
Правильна реалізація createSlice з відповідними name, initialState, та reducers.
Належний експорт дій та редуктора зрізу, що сприяє їх використанню в усьому додатку.
Реалізація та експорт функції селектора selectNameFilter, яка дозволяє легко отримати доступ до стану фільтра.

Завдання вирішено правильно (компонент Contacts slice file)
Ви успішно використали функцію createSlice з Redux Toolkit для управління станом контактів, що є ключовою вимогою цього завдання. Ваше впровадження поля extraReducers для обробки асинхронних дій, таких як fetchContacts, addContact та deleteContact, зроблено правильно, при цьому кожна операція має належно оброблені дії pending, fulfilled та rejected. Це демонструє гарне розуміння обробки асинхронної логіки в Redux Toolkit.
Створення та експорт селектора selectFilteredContacts за допомогою createSelector — це ще одна вимога, якій ви відповідаєте. Цей селектор є життєво важливим для фільтрації контактів на основі критеріїв пошуку, і ви правильно його реалізували, взявши за базу selectContacts та selectNameFilter.
Правильне використання createSlice з extraReducers для обробки асинхронних дій.
Належна реалізація та експорт мемоізованого селектора selectFilteredContacts.

Завдання вирішено правильно (компонент Contacts ops file)
Правильне впровадження createAsyncThunk для асинхронних операцій.
Належне використання axios для здійснення HTTP запитів і встановлення базового URL для спрощення URL запитів.
Точне застосування блоків try...catch у асинхронних функціях для обробки помилок.
Відповідне використання thunkAPI.rejectWithValue для обробки помилок у блоці catch.

Завдання вирішено правильно (компонент Main file)
Коректне імплементування компонента Provider з react-redux, що забезпечує доступність Redux-сховища в аплікації.
Належна передача store як пропа компоненту Provider, що є критично важливим для налаштування Redux.
Включення React.StrictMode для переваг розробки, що демонструє увагу до кращих практик.

Завдання вирішено правильно (компонент ContactList Component)
Імпорт selectFilteredContacts із файлу contactSlice.js виконано правильно.
Метод useSelector() правильно використовується з selectFilteredContacts як аргументом.
Добре виконані моменти:
Ви правильно імпортували необхідний селектор із файлу contactSlice.js.
Використання useSelector() з селектором selectFilteredContacts є належним та відповідає найкращим практикам Redux.

Завдання вирішено правильно (компонент App Component)
Правильне використання useDispatch для доступу до функції відправлення Redux store.
Належне впровадження useEffect з dispatch як залежністю, аби уникнути непотрібних повторних відправлень.
Успішне відправлення дії fetchContacts для ініціювання завантаження даних.
